# Объектно-ориентированное программирование

## Базовые понятия

- **Объект** (экземпляр, инстанс)

        Сущности, у которых есть свойства и поведение. В Kotlin объектами являются любые переменные и константы.

- **Класс**

        Шаблон для объекта. Содержит в себе описание методов, которые есть у объекта, и его свойств (поля класса).

## Основные принципы ООП

- **Абстракция данных**
  
  Свойство классов в объектной парадигме, суть которого в указании лишь важных для решения поставленной задачи свойств класса и методов.

- **Инкапсуляция**
  
  Объединение переменных (и методов, с ними работащих) в одну программную сущность (как правило, в класс), а также скрытие деталей реализации от пользователя (программиста, который создает экземпляр) класса. 

- **Наследование**
  
  Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется **базовым**, **родительским** или **суперклассом**. Новый класс — **потомком** или **наследником**.

- **Полиморфизм**
  
  - Полиморфизм подтипов
    
    Свойство, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
  
  - Параметрический полиморфизм
    
    Свойство, позволяющее использовать методы с одинаковым названием, но разным типом и количеством параметров.

## Принципы SOLID

Принципы SOLID - набор правил, соблюдение которых, как правило, позволяет писать удобный, поддерживаемый и тестируемый код в объектной парадигме.

- **Принцип единственной ответственности (Single Responsibility Principle)**
  
  *Существует лишь одна причина, приводящая к изменению класса.*
  
  Каждый класс, должен выполнять единственную задачу. Он может иметь несколько методов и свойств, но все они должны быть предназначены для решения одной проблемы. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

- **Принцип открытости/закрытости (Open-closed Principle)**
  
  *Программные сущности должны быть открыты для расширения, но закрыты для модификации.*
  
  Классы должны быть расширяемыми без изменения своего содержимого. Если строго соблюдать этот принцип, то можно регулировать поведение кода без изменения самого исходника, путем применения наследования.

- **Принцип подстановки Барбары Лисков (Liskov Substitution Principle)**
  
  *Предварительные условия не могут быть усилены в подтипе.
  Постусловия не могут быть ослаблены в подтипе.
  Инварианты супертипа могут быть сохранены в подтипе.*
  
  Попросту говоря: наследник должен быть взаимозаменяем с родительским классом.

- **Принцип разделения интерфейса (Interface Segregation Principle)**
  
  *Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.*
  
  Нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям пользователей интерфейса.

- **Принцип инверсии зависимостей (Dependency Inversion Principle)**
  
  *Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.*
  
  Это значит, что низкоуровневые сущности не должны влиять на поведение высокоуровневых. Например, если в программе изменился класс X, это не должно влечь изменение классов, использующих его.
